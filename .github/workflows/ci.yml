name: Test, Sonar Scan and Docker Build-Push Workflow

on:
  workflow_call:
    inputs:
      sem-release:
        description: Whether to run a semantic release
        required: false
        type: string
        default: 'true'
      sonar-python:
        description: Whether to Scan code using SonarQube
        required: false
        type: string
        default: 'false'
      sonar-nodejs:
        description: Whether to Scan code using SonarQube
        required: false
        type: string
        default: 'false'
      sonar-dotnet:
        description: Whether to Scan code using SonarQube
        required: false
        type: string
        default: 'false'
      dotnetbuildarguments:
        description: 'Optional command arguments to dotnet build'
        default: 'nofile'
        required: false
        type: string
      nodejs_version:
        description: 'sets node version'
        default: '15.x'
        required: false
        type: string
      python_version:
        description: 'sets python version'
        default: '3.6'
        required: false
        type: string
      dotnet_version:
        description: 'sets .net version for dotnet core application'
        default: '5.0.x'
        required: false
        type: string
      file_check_path_nodejs_test:
        description: 'checks file path to enable nodejs unit test'
        default: "nofile"
        required: false
        type: string
      file_check_path_python_test:
        description: 'checks file path to enable python unit test'
        default: "nofile"
        required: false
        type: string
      file_check_path_python:
        description: 'checks file path to identify as a python pipeline job'
        default: "nofile"
        required: false
        type: string
      file_check_path_nodejs:
        description: 'checks file path to identify as a nodejs pipeline job'
        default: "nofile"
        required: false
        type: string
      file_check_path_dotnet:
        description: 'checks file path to identify as a dotnet pipeline job'
        default: "nofile"
        required: false
        type: string
      repo_name:
        required: true
        type: string
      branch_name:
        required: true
        type: string
      image_name:
        required: true
        type: string
      file:
        description: 'adds the path to the dockerfile ./Dockerfile or root Dockerfile'
        default: 'Dockerfile'
        required: false
        type: string
      context:
        description: 'adds the context path to the dockerfile'
        default: '.'
        required: false
        type: string
    secrets:
      SLACK_WEBHOOK:
        required: true
      SONAR_HOST_URL:
        required: true
      SONAR_TOKEN:
        required: true

jobs:
  build:

    runs-on: self-hosted # ubuntu-latest
    env:
      SonarDotNet: ${{ inputs.sonar-dotnet }}
      SonarPython: ${{ inputs.sonar-python }}
      SonarNodeJS: ${{ inputs.sonar-nodejs }}

    steps:

      - name: âœ…ðŸŽ‰Universal Reusable Workflow 2.0 startedâœ…ðŸŽ‰
        run: echo Universal Reusable Workflow 2.0 started!

      - name: Check for SonarScan value
        run: |
          echo "Sonar-Nodejs value is: $SonarNodeJS"
          echo "Sonar-Python value is: $SonarPython"
          echo "Sonar-DotNet value is: $SonarDotNet"

      - name: Checkout
        uses: actions/checkout@v2
        with:
          # Disabling shallow clone is recommended for improving relevancy of sonarqube reporting
          fetch-depth: 0

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v1
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
        with:
          driver: docker
      
      - name: Check file existence for Nodejs
        id: check_files_nodejs
        uses: submittable/file-existence-action@v1
        with:
          files: "${{ inputs.file_check_path_nodejs }}"
      
      - name: Check file existence for Python
        id: check_files_python
        uses: submittable/file-existence-action@v1
        with:
          files: "${{ inputs.file_check_path_python }}"
      
      - name: Check file existence for .Net
        id: check_files_dotnet
        uses: submittable/file-existence-action@v1
        with:
          files: "${{ inputs.file_check_path_dotnet }}"
      
      - name: Setup Nuget
        if: steps.check_files_dotnet.outputs.files_exists == 'true'
        uses: Nuget/setup-nuget@v1.0.5
      
#       - name: Add msbuild to PATH
#         if: steps.check_files_dotnet.outputs.files_exists == 'true'
#         uses: microsoft/setup-msbuild@v1.0.2

      - name: Check file existence for Dockerfile
        id: check_files_docker
        uses: submittable/file-existence-action@v1
        with:
          files: "Dockerfile"

      - name: Check file existence for Node Testfiles
        id: check_files_nodejs_test
        uses: submittable/file-existence-action@v1
        with:
          files: "${{ inputs.file_check_path_nodejs_test }}"
      
      - name: Check file existence for Python Testfiles
        id: check_files_python_test
        uses: submittable/file-existence-action@v1
        with:
          files: "${{ inputs.file_check_path_python_test }}"

      - name: Set Node Version
        if: steps.check_files_nodejs.outputs.files_exists == 'true'
        # Only runs if all of the files exists
        uses: actions/setup-node@v2
        with:
          node-version: ${{ inputs.nodejs_version }}
      
      - name: Set Python Version
        if: steps.check_files_python.outputs.files_exists == 'true'
        uses: actions/setup-python@v2
        with:
          python-version: ${{ inputs.python_version }}
      
      - name: Setup DotNet Version
        if: steps.check_files_dotnet.outputs.files_exists == 'true'
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: '${{ inputs.dotnet_version }}'
      
      - name: Install Nodejs Dependencies
        if: steps.check_files_nodejs.outputs.files_exists == 'true'
        run: npm ci
      
      - name: Install Python Dependencies
        if: steps.check_files_python.outputs.files_exists == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
      
      - name: Install DotNet dependencies
        if: steps.check_files_dotnet.outputs.files_exists == 'true'
        run: dotnet restore

      - name: Build Nodejs App
        if: steps.check_files_nodejs.outputs.files_exists == 'true'
        run: npm run build --if-present
      
      - name: Build Python App
        if: steps.check_files_python.outputs.files_exists == 'true'
        run: |
          # stop the build if there are Python syntax errors or undefined names
          # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
          flake8 . --count --select=E9,F63,F7,F82 --exit-zero --max-complexity=10 --max-line-length=127 --show-source --statistics
        
      - name: Restore nuget packages
        if: steps.check_files_dotnet.outputs.files_exists == 'true'
        run: dotnet restore
        # run: nuget restore ./${{ inputs.file_check_path_dotnet }}
      
      - name: Build DotNet App
        if: steps.check_files_dotnet.outputs.files_exists == 'true'
        run: dotnet build

      - name: Run Nodejs tests
        if: steps.check_files_nodejs_test.outputs.files_exists == 'true'
        run: npm test
      
      - name: Run Python tests
        if: steps.check_files_python_test.outputs.files_exists == 'true'
        run: python -m unittest discover tests

#Build fails running tests, so commenting until we have a working test case
#       - name: Run .Net test with .Net CLI
#         if: steps.check_files_dotnet.outputs.files_exists == 'true'
#         run: dotnet test --settings coverlet.runsettings --logger:trx
#         env:
#           ASPNETCORE_ENVIRONMENT: Development

      - name: Archive production artifacts
        if: steps.check_files_nodejs_test.outputs.files_exists == 'true'
        uses: actions/upload-artifact@v2
        with:
          name: dist-without-markdown
          path: |
            dist
            !dist/**/*.md

      - name: Archive code coverage results
        if: steps.check_files_nodejs_test.outputs.files_exists == 'true'
        uses: actions/upload-artifact@v2
        with:
          name: code-coverage-report
          path: output/test/code-coverage.html
          retention-days: 5
    
    #Enable only when Sonar server is available. It will run Static Code Analysis
      - name: Run Sonar Scan - Nodejs
        if: ${{ inputs.sonar-nodejs == 'true' }}
        uses: sonarsource/sonarqube-scan-action@master
        with:
          projectBaseDir: .
          args: >
            -Dsonar.projectName=${{ inputs.repo_name }}
            -Dsonar.projectVersion=1.0.0
            -Dsonar.verbose=true
            -Dsonar.projectKey=${{ inputs.repo_name }}
        env:
         SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
         SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Run Sonar Scan - Python
        if: ${{ inputs.sonar-python == 'true' }}
        uses: sonarsource/sonarqube-scan-action@master
        with:
          projectBaseDir: .
          args: >
            -Dsonar.python.coverage.reportPaths=coverage.xml
            -Dsonar.verbose=true
            -Dsonar.projectKey=${{ inputs.repo_name }}
            -Dsonar.sources=.
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      
      - name: SonarScanner for .NET
        if: ${{ inputs.sonar-dotnet == 'true' }}
        uses: submittable/sonarscan-dotnet@v2.1.2
        with:
          # The key of the SonarQube project
          sonarProjectKey: ${{ inputs.repo_name }}
          # The name of the SonarQube project
          sonarProjectName:  ${{ inputs.repo_name }}
          # Optional command arguments to dotnet build
          dotnetBuildArguments: ./${{ inputs.dotnetbuildarguments }}
          # Optional. Set to 1 or true to not run 'dotnet test' command
          dotnetDisableTests: true
          # The SonarQube server URL. For SonarCloud, skip this setting.
          sonarHostname:  ${{ secrets.SONAR_HOST_URL }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Reads the latest tag on the repo and increments its minor verions
      # Increment style can be changed by including a #major, #minor, or #patch in a commit message
      - name: Bump version and push tag
        id: tag_version
        uses: submittable/github-tag-action@1.36.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BRANCHES: main
          WITH_V: true
          #INITIAL_VERSION: 0.0.0 #Set initial version before bump. Default is 0.0.0
      
      # Attempt to make the REF string valid docker tag syntax
      - name: Extract source branch/pr name
        shell: bash
        run: |
          TEMP=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          echo "##[set-output name=branch;]$(echo ${TEMP///-})"
        id: extract_ref_tag
      
      # Collate the image name, tags, and labels for push command
      - name: Extract metadata (tags, labels)
#         if: steps.check_files_docker.outputs.files_exists == 'true'
        id: meta
        uses: docker/metadata-action@v3.5.0
        with:
          images: ghcr.io/${{ inputs.image_name }}
          tags: |
            type=raw,value=latest,enable=${{ endsWith(GitHub.ref, 'main') }}
            type=raw,value=${{ steps.tag_version.outputs.new_tag }}
            type=raw,value=${{ steps.extract_ref_tag.outputs.branch }}
            type=raw,value=${{ GitHub.sha }}
      
      # Build, Tag and Push the docker image to Github Container Registry
      - name: Build, Tag and Push Docker Image
#         if: steps.check_files_docker.outputs.files_exists == 'true'
        uses: docker/build-push-action@v2.7.0
        with:
          context: ${{ inputs.context }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          file: ${{ inputs.file }}
      
      # Creates a Github release with the new semantic version
      - name: Create a GitHub Semantic release
        if: ${{ inputs.sem-release == 'true' }}
        # if: endsWith(GitHub.ref, 'main') && success()
        # if: ${{ success() && (github.ref == 'refs/heads/main' || github.base_ref == 'main') }}
        uses: actions/create-release@v1.1.4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag_version.outputs.new_tag }}
          release_name: ${{ steps.tag_version.outputs.new_tag }}
          body: ${{ steps.tag_version.outputs.changelog }}

      # - name: Update Image

      # Sends a slack notification to slack build channel on Success
      - name: Slack Notification - On Success
        if: endsWith(GitHub.ref, 'main') && success()
        uses: submittable/action-slack-notify@v2.2.0
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_MESSAGE: Build job for Release ${{ steps.tag_version.outputs.new_tag }} completed successfully!
          SLACK_FOOTER: Powered By Submittable GitHub Actions Library
      
      # Sends a slack notification to slack build channel if Dockerfile is not present
      - name: Slack Notification - Dockerfile not Present
        if: steps.check_files_docker.outputs.files_exists == 'false'
        uses: submittable/action-slack-notify@v2.2.0
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_COLOR: #fff00
          SLACK_MESSAGE: Dockerfile not found for ${{ steps.tag_version.outputs.new_tag }} - will continue build.
          SLACK_FOOTER: Powered By Submittable GitHub Actions Library

      # Sends a slack notification to slack build channel on Failure
      - name: Slack Notification - On Failure
        if: endsWith(GitHub.ref, 'main') && failure()
        uses: submittable/action-slack-notify@v2.2.0
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_COLOR: ${{ job.status }}
          SLACK_MESSAGE: Build job for Release ${{ steps.tag_version.outputs.new_tag }} FAILED!
          SLACK_FOOTER: Powered By Submittable GitHub Actions Library
